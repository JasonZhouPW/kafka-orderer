// Code generated by protoc-gen-go.
// source: ab.proto
// DO NOT EDIT!

/*
Package ab is a generated protocol buffer package.

It is generated from these files:
	ab.proto

It has these top-level messages:
	BroadcastReply
	BroadcastMessage
	SeekInfo
	Acknowledgement
	DeliverUpdate
	Block
	DeliverReply
*/
package ab

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// These status codes are intended to resemble selected HTTP status codes
type Status int32

const (
	Status_SUCCESS             Status = 0
	Status_BAD_REQUEST         Status = 400
	Status_FORBIDDEN           Status = 403
	Status_NOT_FOUND           Status = 404
	Status_SERVICE_UNAVAILABLE Status = 503
)

var Status_name = map[int32]string{
	0:   "SUCCESS",
	400: "BAD_REQUEST",
	403: "FORBIDDEN",
	404: "NOT_FOUND",
	503: "SERVICE_UNAVAILABLE",
}
var Status_value = map[string]int32{
	"SUCCESS":             0,
	"BAD_REQUEST":         400,
	"FORBIDDEN":           403,
	"NOT_FOUND":           404,
	"SERVICE_UNAVAILABLE": 503,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Start may be specified to a specific block number, or may be request from the newest or oldest available
// The start location is always inclusive, so the first reply from NEWEST will contain the newest block at the time
// of reception, it will must not wait until a new block is created.  Similarly, when SPECIFIED, and specified_number = 10
// The first block received must be block 10, not block 11
type SeekInfo_Start int32

const (
	SeekInfo_NEWEST    SeekInfo_Start = 0
	SeekInfo_OLDEST    SeekInfo_Start = 1
	SeekInfo_SPECIFIED SeekInfo_Start = 2
)

var SeekInfo_Start_name = map[int32]string{
	0: "NEWEST",
	1: "OLDEST",
	2: "SPECIFIED",
}
var SeekInfo_Start_value = map[string]int32{
	"NEWEST":    0,
	"OLDEST":    1,
	"SPECIFIED": 2,
}

func (x SeekInfo_Start) String() string {
	return proto.EnumName(SeekInfo_Start_name, int32(x))
}
func (SeekInfo_Start) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type BroadcastReply struct {
	Status Status `protobuf:"varint,1,opt,name=status,enum=ab.Status" json:"status,omitempty"`
}

func (m *BroadcastReply) Reset()                    { *m = BroadcastReply{} }
func (m *BroadcastReply) String() string            { return proto.CompactTextString(m) }
func (*BroadcastReply) ProtoMessage()               {}
func (*BroadcastReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type BroadcastMessage struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *BroadcastMessage) Reset()                    { *m = BroadcastMessage{} }
func (m *BroadcastMessage) String() string            { return proto.CompactTextString(m) }
func (*BroadcastMessage) ProtoMessage()               {}
func (*BroadcastMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type SeekInfo struct {
	Start           SeekInfo_Start `protobuf:"varint,1,opt,name=start,enum=ab.SeekInfo_Start" json:"start,omitempty"`
	SpecifiedNumber uint64         `protobuf:"varint,2,opt,name=specified_number,json=specifiedNumber" json:"specified_number,omitempty"`
	WindowSize      uint64         `protobuf:"varint,3,opt,name=window_size,json=windowSize" json:"window_size,omitempty"`
}

func (m *SeekInfo) Reset()                    { *m = SeekInfo{} }
func (m *SeekInfo) String() string            { return proto.CompactTextString(m) }
func (*SeekInfo) ProtoMessage()               {}
func (*SeekInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type Acknowledgement struct {
	Number uint64 `protobuf:"varint,1,opt,name=number" json:"number,omitempty"`
}

func (m *Acknowledgement) Reset()                    { *m = Acknowledgement{} }
func (m *Acknowledgement) String() string            { return proto.CompactTextString(m) }
func (*Acknowledgement) ProtoMessage()               {}
func (*Acknowledgement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// The update message either causes a seek to a new stream start with a new window, or acknowledges a received block and advances the base of the window
type DeliverUpdate struct {
	// Types that are valid to be assigned to Type:
	//	*DeliverUpdate_Acknowledgement
	//	*DeliverUpdate_Seek
	Type isDeliverUpdate_Type `protobuf_oneof:"type"`
}

func (m *DeliverUpdate) Reset()                    { *m = DeliverUpdate{} }
func (m *DeliverUpdate) String() string            { return proto.CompactTextString(m) }
func (*DeliverUpdate) ProtoMessage()               {}
func (*DeliverUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isDeliverUpdate_Type interface {
	isDeliverUpdate_Type()
}

type DeliverUpdate_Acknowledgement struct {
	Acknowledgement *Acknowledgement `protobuf:"bytes,1,opt,name=acknowledgement,oneof"`
}
type DeliverUpdate_Seek struct {
	Seek *SeekInfo `protobuf:"bytes,2,opt,name=seek,oneof"`
}

func (*DeliverUpdate_Acknowledgement) isDeliverUpdate_Type() {}
func (*DeliverUpdate_Seek) isDeliverUpdate_Type()            {}

func (m *DeliverUpdate) GetType() isDeliverUpdate_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DeliverUpdate) GetAcknowledgement() *Acknowledgement {
	if x, ok := m.GetType().(*DeliverUpdate_Acknowledgement); ok {
		return x.Acknowledgement
	}
	return nil
}

func (m *DeliverUpdate) GetSeek() *SeekInfo {
	if x, ok := m.GetType().(*DeliverUpdate_Seek); ok {
		return x.Seek
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DeliverUpdate) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DeliverUpdate_OneofMarshaler, _DeliverUpdate_OneofUnmarshaler, _DeliverUpdate_OneofSizer, []interface{}{
		(*DeliverUpdate_Acknowledgement)(nil),
		(*DeliverUpdate_Seek)(nil),
	}
}

func _DeliverUpdate_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DeliverUpdate)
	// type
	switch x := m.Type.(type) {
	case *DeliverUpdate_Acknowledgement:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Acknowledgement); err != nil {
			return err
		}
	case *DeliverUpdate_Seek:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Seek); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DeliverUpdate.Type has unexpected type %T", x)
	}
	return nil
}

func _DeliverUpdate_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DeliverUpdate)
	switch tag {
	case 1: // type.acknowledgement
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Acknowledgement)
		err := b.DecodeMessage(msg)
		m.Type = &DeliverUpdate_Acknowledgement{msg}
		return true, err
	case 2: // type.seek
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SeekInfo)
		err := b.DecodeMessage(msg)
		m.Type = &DeliverUpdate_Seek{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DeliverUpdate_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DeliverUpdate)
	// type
	switch x := m.Type.(type) {
	case *DeliverUpdate_Acknowledgement:
		s := proto.Size(x.Acknowledgement)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DeliverUpdate_Seek:
		s := proto.Size(x.Seek)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Block struct {
	Number   uint64              `protobuf:"varint,2,opt,name=number" json:"number,omitempty"`
	PrevHash []byte              `protobuf:"bytes,3,opt,name=prev_hash,json=prevHash,proto3" json:"prev_hash,omitempty"`
	Proof    []byte              `protobuf:"bytes,4,opt,name=proof,proto3" json:"proof,omitempty"`
	Messages []*BroadcastMessage `protobuf:"bytes,5,rep,name=messages" json:"messages,omitempty"`
}

func (m *Block) Reset()                    { *m = Block{} }
func (m *Block) String() string            { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()               {}
func (*Block) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Block) GetMessages() []*BroadcastMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type DeliverReply struct {
	// Types that are valid to be assigned to Type:
	//	*DeliverReply_Error
	//	*DeliverReply_Block
	Type isDeliverReply_Type `protobuf_oneof:"type"`
}

func (m *DeliverReply) Reset()                    { *m = DeliverReply{} }
func (m *DeliverReply) String() string            { return proto.CompactTextString(m) }
func (*DeliverReply) ProtoMessage()               {}
func (*DeliverReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isDeliverReply_Type interface {
	isDeliverReply_Type()
}

type DeliverReply_Error struct {
	Error Status `protobuf:"varint,1,opt,name=error,enum=ab.Status,oneof"`
}
type DeliverReply_Block struct {
	Block *Block `protobuf:"bytes,2,opt,name=block,oneof"`
}

func (*DeliverReply_Error) isDeliverReply_Type() {}
func (*DeliverReply_Block) isDeliverReply_Type() {}

func (m *DeliverReply) GetType() isDeliverReply_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DeliverReply) GetError() Status {
	if x, ok := m.GetType().(*DeliverReply_Error); ok {
		return x.Error
	}
	return Status_SUCCESS
}

func (m *DeliverReply) GetBlock() *Block {
	if x, ok := m.GetType().(*DeliverReply_Block); ok {
		return x.Block
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DeliverReply) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DeliverReply_OneofMarshaler, _DeliverReply_OneofUnmarshaler, _DeliverReply_OneofSizer, []interface{}{
		(*DeliverReply_Error)(nil),
		(*DeliverReply_Block)(nil),
	}
}

func _DeliverReply_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DeliverReply)
	// type
	switch x := m.Type.(type) {
	case *DeliverReply_Error:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Error))
	case *DeliverReply_Block:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Block); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DeliverReply.Type has unexpected type %T", x)
	}
	return nil
}

func _DeliverReply_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DeliverReply)
	switch tag {
	case 1: // type.error
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &DeliverReply_Error{Status(x)}
		return true, err
	case 2: // type.block
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Block)
		err := b.DecodeMessage(msg)
		m.Type = &DeliverReply_Block{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DeliverReply_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DeliverReply)
	// type
	switch x := m.Type.(type) {
	case *DeliverReply_Error:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Error))
	case *DeliverReply_Block:
		s := proto.Size(x.Block)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*BroadcastReply)(nil), "ab.broadcast_reply")
	proto.RegisterType((*BroadcastMessage)(nil), "ab.broadcast_message")
	proto.RegisterType((*SeekInfo)(nil), "ab.seek_info")
	proto.RegisterType((*Acknowledgement)(nil), "ab.acknowledgement")
	proto.RegisterType((*DeliverUpdate)(nil), "ab.deliver_update")
	proto.RegisterType((*Block)(nil), "ab.block")
	proto.RegisterType((*DeliverReply)(nil), "ab.deliver_reply")
	proto.RegisterEnum("ab.Status", Status_name, Status_value)
	proto.RegisterEnum("ab.SeekInfo_Start", SeekInfo_Start_name, SeekInfo_Start_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for AtomicBroadcast service

type AtomicBroadcastClient interface {
	// broadcast receives a reply of acknowledgement for each broadcast_message in order, indicating success or type of failure
	Broadcast(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_BroadcastClient, error)
	// deliver first requires an update containing a seek message, then a stream of block replies is received.
	// The receiver may choose to send an acknowledgement for any block number it receives, however acknowledgements must never be more than window_size apart
	// To avoid latency, clients will likely acknowledge before the window_size has been exhausted, preventing the server from stopping and waiting for an acknowledgement
	Deliver(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_DeliverClient, error)
}

type atomicBroadcastClient struct {
	cc *grpc.ClientConn
}

func NewAtomicBroadcastClient(cc *grpc.ClientConn) AtomicBroadcastClient {
	return &atomicBroadcastClient{cc}
}

func (c *atomicBroadcastClient) Broadcast(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_BroadcastClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AtomicBroadcast_serviceDesc.Streams[0], c.cc, "/ab.atomic_broadcast/broadcast", opts...)
	if err != nil {
		return nil, err
	}
	x := &atomicBroadcastBroadcastClient{stream}
	return x, nil
}

type AtomicBroadcast_BroadcastClient interface {
	Send(*BroadcastMessage) error
	Recv() (*BroadcastReply, error)
	grpc.ClientStream
}

type atomicBroadcastBroadcastClient struct {
	grpc.ClientStream
}

func (x *atomicBroadcastBroadcastClient) Send(m *BroadcastMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *atomicBroadcastBroadcastClient) Recv() (*BroadcastReply, error) {
	m := new(BroadcastReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *atomicBroadcastClient) Deliver(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_DeliverClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AtomicBroadcast_serviceDesc.Streams[1], c.cc, "/ab.atomic_broadcast/deliver", opts...)
	if err != nil {
		return nil, err
	}
	x := &atomicBroadcastDeliverClient{stream}
	return x, nil
}

type AtomicBroadcast_DeliverClient interface {
	Send(*DeliverUpdate) error
	Recv() (*DeliverReply, error)
	grpc.ClientStream
}

type atomicBroadcastDeliverClient struct {
	grpc.ClientStream
}

func (x *atomicBroadcastDeliverClient) Send(m *DeliverUpdate) error {
	return x.ClientStream.SendMsg(m)
}

func (x *atomicBroadcastDeliverClient) Recv() (*DeliverReply, error) {
	m := new(DeliverReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AtomicBroadcast service

type AtomicBroadcastServer interface {
	// broadcast receives a reply of acknowledgement for each broadcast_message in order, indicating success or type of failure
	Broadcast(AtomicBroadcast_BroadcastServer) error
	// deliver first requires an update containing a seek message, then a stream of block replies is received.
	// The receiver may choose to send an acknowledgement for any block number it receives, however acknowledgements must never be more than window_size apart
	// To avoid latency, clients will likely acknowledge before the window_size has been exhausted, preventing the server from stopping and waiting for an acknowledgement
	Deliver(AtomicBroadcast_DeliverServer) error
}

func RegisterAtomicBroadcastServer(s *grpc.Server, srv AtomicBroadcastServer) {
	s.RegisterService(&_AtomicBroadcast_serviceDesc, srv)
}

func _AtomicBroadcast_Broadcast_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AtomicBroadcastServer).Broadcast(&atomicBroadcastBroadcastServer{stream})
}

type AtomicBroadcast_BroadcastServer interface {
	Send(*BroadcastReply) error
	Recv() (*BroadcastMessage, error)
	grpc.ServerStream
}

type atomicBroadcastBroadcastServer struct {
	grpc.ServerStream
}

func (x *atomicBroadcastBroadcastServer) Send(m *BroadcastReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *atomicBroadcastBroadcastServer) Recv() (*BroadcastMessage, error) {
	m := new(BroadcastMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AtomicBroadcast_Deliver_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AtomicBroadcastServer).Deliver(&atomicBroadcastDeliverServer{stream})
}

type AtomicBroadcast_DeliverServer interface {
	Send(*DeliverReply) error
	Recv() (*DeliverUpdate, error)
	grpc.ServerStream
}

type atomicBroadcastDeliverServer struct {
	grpc.ServerStream
}

func (x *atomicBroadcastDeliverServer) Send(m *DeliverReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *atomicBroadcastDeliverServer) Recv() (*DeliverUpdate, error) {
	m := new(DeliverUpdate)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _AtomicBroadcast_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ab.atomic_broadcast",
	HandlerType: (*AtomicBroadcastServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "broadcast",
			Handler:       _AtomicBroadcast_Broadcast_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "deliver",
			Handler:       _AtomicBroadcast_Deliver_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("ab.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 557 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x53, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xad, 0x93, 0xd8, 0x8d, 0x27, 0x4d, 0xe2, 0x6e, 0x00, 0x59, 0xe5, 0x40, 0x31, 0x07, 0x5a,
	0x0e, 0x11, 0x04, 0xc1, 0x0d, 0xa1, 0x24, 0x76, 0xd4, 0x48, 0x91, 0x03, 0x76, 0x53, 0x6e, 0x58,
	0xeb, 0x78, 0xd3, 0x5a, 0xf9, 0xb0, 0xb5, 0x76, 0x1a, 0x95, 0x03, 0x37, 0x0e, 0xdc, 0x90, 0xe0,
	0x97, 0xf0, 0xe7, 0xb8, 0xb2, 0xbb, 0x76, 0xd2, 0x84, 0x70, 0x9b, 0x79, 0x33, 0x6f, 0x76, 0xde,
	0xcc, 0x2c, 0x94, 0xb1, 0xdf, 0x8c, 0x69, 0x94, 0x46, 0xa8, 0x80, 0x7d, 0xe3, 0x0d, 0xd4, 0x7d,
	0x1a, 0xe1, 0x60, 0x8c, 0x93, 0xd4, 0xa3, 0x24, 0x9e, 0xdd, 0x21, 0x03, 0x94, 0x24, 0xc5, 0xe9,
	0x32, 0xd1, 0xa5, 0x53, 0xe9, 0xac, 0xd6, 0x82, 0x26, 0x63, 0xb8, 0x02, 0x71, 0xf2, 0x88, 0xf1,
	0x1c, 0x8e, 0xef, 0x69, 0x73, 0x92, 0x24, 0xf8, 0x9a, 0x20, 0x04, 0xa5, 0x00, 0xa7, 0x58, 0xd0,
	0x8e, 0x1c, 0x61, 0x1b, 0xbf, 0x25, 0x50, 0x13, 0x42, 0xa6, 0x5e, 0xb8, 0x98, 0x44, 0xe8, 0x1c,
	0x64, 0x56, 0x80, 0xa6, 0x79, 0xe5, 0x06, 0xaf, 0xbc, 0x89, 0xf2, 0x37, 0x68, 0xea, 0x64, 0x19,
	0x2c, 0x55, 0x4b, 0x62, 0x32, 0x0e, 0x27, 0x21, 0x09, 0xbc, 0xc5, 0x72, 0xee, 0x13, 0xaa, 0x17,
	0x18, 0xab, 0xe4, 0xd4, 0x37, 0xb8, 0x2d, 0x60, 0xf4, 0x04, 0x2a, 0xab, 0x70, 0x11, 0x44, 0x2b,
	0x2f, 0x09, 0xbf, 0x10, 0xbd, 0x28, 0xb2, 0x20, 0x83, 0x5c, 0x86, 0x18, 0x4d, 0x90, 0x45, 0x6d,
	0x04, 0xa0, 0xd8, 0xd6, 0x27, 0xcb, 0xbd, 0xd4, 0x0e, 0xb8, 0x3d, 0x1c, 0x98, 0xdc, 0x96, 0x50,
	0x15, 0x54, 0xf7, 0x83, 0xd5, 0xed, 0xf7, 0xfa, 0x96, 0xa9, 0x15, 0x8c, 0x73, 0xa8, 0xe3, 0xf1,
	0x74, 0x11, 0xad, 0x66, 0x24, 0xb8, 0x26, 0x73, 0xb2, 0x48, 0xd1, 0x23, 0x50, 0xf2, 0x26, 0x24,
	0x51, 0x3e, 0xf7, 0x8c, 0xaf, 0x50, 0x0b, 0xc8, 0x2c, 0xbc, 0x25, 0xd4, 0x5b, 0xc6, 0x4c, 0x31,
	0x41, 0xef, 0xf7, 0xc8, 0x82, 0x52, 0xc9, 0xd4, 0xfe, 0x13, 0xba, 0x38, 0x70, 0xf6, 0x9e, 0x7a,
	0x06, 0x25, 0x3e, 0x13, 0xa1, 0xb6, 0xd2, 0xaa, 0xee, 0xcc, 0x88, 0xe5, 0x8b, 0x60, 0x47, 0x81,
	0x52, 0x7a, 0x17, 0x13, 0xe3, 0x9b, 0x04, 0xb2, 0x3f, 0x8b, 0xc6, 0xd3, 0xad, 0x0e, 0x0b, 0xdb,
	0x1d, 0xa2, 0xc7, 0xa0, 0xc6, 0x94, 0xdc, 0x7a, 0x37, 0x38, 0xb9, 0x11, 0xb3, 0x39, 0x72, 0xca,
	0x1c, 0xb8, 0x60, 0x3e, 0x7a, 0x00, 0x32, 0xbb, 0x85, 0x68, 0xa2, 0x97, 0x44, 0x20, 0x73, 0xd0,
	0x2b, 0x28, 0xe7, 0x3b, 0x4d, 0x74, 0xf9, 0xb4, 0xc8, 0xba, 0x78, 0xc8, 0xbb, 0xd8, 0xdb, 0xb8,
	0xb3, 0x49, 0x33, 0x3e, 0x43, 0x75, 0x3d, 0x87, 0xf5, 0x15, 0xc9, 0x84, 0xd2, 0x88, 0xee, 0x1f,
	0x11, 0xd3, 0x90, 0x85, 0xd0, 0xd3, 0xbc, 0xf7, 0x5c, 0xaa, 0x2a, 0x1e, 0xe1, 0x00, 0x4f, 0x11,
	0xc6, 0x5a, 0xe7, 0x0b, 0x0c, 0x4a, 0xc6, 0x46, 0x15, 0x38, 0x74, 0x47, 0xdd, 0xae, 0xe5, 0xba,
	0x6c, 0x89, 0x1a, 0x54, 0x3a, 0x6d, 0xd3, 0x73, 0xac, 0x8f, 0x23, 0xbe, 0xc9, 0x1f, 0x45, 0x54,
	0x03, 0xb5, 0x37, 0x74, 0x3a, 0x7d, 0xd3, 0xb4, 0x6c, 0xed, 0xa7, 0xf0, 0xed, 0xe1, 0xa5, 0xd7,
	0x1b, 0x8e, 0x6c, 0x53, 0xfb, 0x55, 0x44, 0x3a, 0x34, 0x5c, 0xcb, 0xb9, 0xea, 0x77, 0x2d, 0x6f,
	0x64, 0xb7, 0xaf, 0xda, 0xfd, 0x41, 0xbb, 0x33, 0xb0, 0xb4, 0x3f, 0xc5, 0xd6, 0x77, 0x09, 0x34,
	0x9c, 0x46, 0xf3, 0x70, 0xec, 0x6d, 0x94, 0xa2, 0x77, 0xa0, 0xde, 0x3b, 0xff, 0x9f, 0xc2, 0x49,
	0x63, 0x17, 0x16, 0xfa, 0x8d, 0x83, 0x33, 0xe9, 0xa5, 0x84, 0xde, 0xc2, 0x61, 0x3e, 0x16, 0x84,
	0x78, 0xd6, 0xee, 0xad, 0x9c, 0x1c, 0x6f, 0x63, 0x5b, 0x3c, 0x5f, 0x11, 0x3f, 0xf4, 0xf5, 0xdf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x81, 0xf8, 0xbd, 0x9a, 0xad, 0x03, 0x00, 0x00,
}
